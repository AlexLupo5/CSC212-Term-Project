#include <iostream>
#include "convexHull.h"
#include <cmath>

convexHull::convexHull(std::string fileName) {
    this->fileName = fileName;
    convertToPoint();

    if(pointsTemp.size() < 3) {
        std::cout << "Convex Hull is not possible" << std::endl;
    }

    Point points[pointsTemp.size()];

    for(int i = 0; i < pointsTemp.size(); i++) {
        points[i].x = pointsTemp[i].x;
        points[i].y = pointsTemp[i].y;
    }

    convexHullSolve(points, pointsTemp.size());
}

convexHull::~convexHull(){

}

void convexHull::convexHullSolve(Point points[], int size){
    int lowesty = points[0].y;
    int lowestval = 0;
    for (int i = 0; i < size; i++){
        int y = points[i].y;

        if ((y < lowesty) || ((lowesty == y
        && points[i].x < points[lowestval].x))){
            lowesty = points[i].y;
            lowestval = i;
        }
    }

    Point ptemp = points[0];
    points[0] = points[lowestval];
    points[lowestval] = ptemp;

    temp = points[0];

std::vector <Point> pointSort;
    for(int i = 1; i < pointsTemp.size(); i++) {
        pointSort.push_back(points[i]);
    }

    int num = pointSort.size();

    for(int i = 1; i <= num; i++) {
        int ang = 0;

        for(int j = 0; j < pointSort.size(); j++) {

            if (polarAngle(pointSort[ang].x - points[0].x,
                           pointSort[ang].y - points[0].y) ==
                polarAngle(pointSort[j].x - points[0].x,
                           pointSort[j].y - points[0].y)) {

                if((sqrt(pow(pointSort[ang].x - points[0].x,2) + pow(pointSort[ang].y - points[0].y, 2))) >
                   (sqrt(pow(pointSort[j].x - points[0].x,2) + pow(pointSort[j].y - points[0].y, 2)))) {
                    ang = j;
                }
            } else {

            if (polarAngle(pointSort[ang].x - points[0].x,
                           pointSort[ang].y - points[0].y) >
                polarAngle(pointSort[j].x - points[0].x,
                           pointSort[j].y - points[0].y)) {
                    ang = j;
                }
            }
        }
        points[i] = (pointSort[ang]);
        pointSort.erase(pointSort.begin() + ang);
    }

    int index = 1;
    for (int i = 1; i < size; i++){
        while ((i < size - 1) && (orientation(temp, points[i],points[i + 1]) == 0)){
            i++;
        }
        points[index] = points[i];
        index = index + 1;
    }

    if (index < 3){
        return;
    }

    for(int i = 0; i < 3; i++) {
        output.push_back(points[i]);
    }

    for (int i = 3; i < index; i++){
        while (output.size() > 1 && orientation(Top(output), output[output.size() - 1], points[i]) != 2){
            output.pop_back();
        }
        output.push_back(points[i]);
    }

}

Point convexHull::temp = Point();

Point convexHull::Top(std::vector<Point> &vect){
    Point point = vect[vect.size()-1];
    vect.pop_back();
    Point answer = vect[vect.size()-1];
    vect.push_back(point);
    return answer;
}

double convexHull::polarAngle(double x, double y) { //Returns the polarAngle of the given (x,y) coordinates
    return std::atan2(y, x) * (180.0 / M_PI);
}

int convexHull::orientation(Point point1, Point point2, Point point3){
    int orient = (point2.y - point1.y) * (point3.x - point2.x)
            - (point2.x - point1.x) * (point3.y - point2.y);

    //Colinear
    if (orient >= 0) {
        //Clockwise
        if (orient > 0){
            return 1;
        }
        else {
            return 0;
        }
    }
        //Counterclockwise
    else{
        return 2;
    }
}

void convexHull::convertToPoint() { //convertToPoint function
    //Reads through the inputFile and puts all x coordinates into
    //points.x vector and all y coordinates in points.y vector
    std::ifstream infile(fileName);
    std::string line;
    int num = 0;
    std::string x;

    while (getline(infile, line)) {
        std::stringstream strLine(line);
        int tempx = 0;
        int tempy = 0;
        while (strLine >> x) {
            std::string temp = "";

            int i = 1;
            while (x[i] != ',') {
                temp += x[i];
                i++;
            }
            tempx = std::stoi(temp);
            i++;
            temp.clear();

            while (x[i] != ')') {
                temp += x[i];
                i++;
            }
            tempy = std::stoi(temp);
        }

        bool duplCheck = false; //Check for duplicate points
        for(int j = 0; j < pointsTemp.size(); j++) {
            if((pointsTemp[j].x == tempx) && (pointsTemp[j].y == tempy)) {
                duplCheck = true;
            }
        }
        if(duplCheck == false) {
            pointsTemp.push_back({tempx, tempy});
        }
    }
}

void convexHull::print() {
std::vector<Point> out = output;

    while (out.size() > 0){
        Point point = out[out.size()-1];
        std::cout << "(" << point.x << ", " << point.y <<")\n";
        out.pop_back();
    }
}

void convexHull::dot() {
    std::vector<Point> out = output;
    std::ofstream File("convexHull.dot"); // Create or open a dot file named "output.dot"

    if (!File.is_open()) {
        std::cout << "Could not open the dot file." << std::endl;
    }

    if(pointsTemp.size() < 3) {
        //File << "Convex Hull is not possible" << std::endl;
    }

    else {
        while (out.size() > 0) {
            Point point = out[out.size() - 1];
            File << "(" << point.x << "," << point.y << ")";
            if (out.size() > 1) {
                File << "\n";
            }
            out.pop_back();
        }
    }
}
